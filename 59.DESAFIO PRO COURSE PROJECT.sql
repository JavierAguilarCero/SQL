/*
ESTE COMANDO CREA UNA TABLA LLAMADA 'employees' PARA ALMACENAR INFORMACIÓN DE EMPLEADOS. INCLUYE CAMPOS COMO ID DE EMPLEADO (CLAVE PRIMARIA), NOMBRE, APELLIDO, PUESTO DE
TRABAJO, SALARIO, FECHA DE INICIO, FECHA DE NACIMIENTO, ID DE TIENDA (CON REFERENCIA A LA TABLA 'store'), ID DE DEPARTAMENTO E ID DE GERENTE.
*/
CREATE TABLE employees
	(
	emp_id SERIAL PRIMARY KEY,
	first_name TEXT NOT NULL,
	last_name TEXT NOT NULL,
	job_position TEXT NOT NULL,
	salary DECIMAL(8,2),
	start_date DATE NOT NULL,
	birth_date DATE NOT NULL,
	store_id INT REFERENCES store(store_id),
	department_id INT,
	manager_id INT
	)
/*
ESTE COMANDO CREA UNA TABLA LLAMADA 'departments' PARA ALMACENAR INFORMACIÓN DE LOS DEPARTAMENTOS DE UNA ORGANIZACIÓN. INCLUYE UN ID DE DEPARTAMENTO COMO CLAVE PRIMARIA,
EL NOMBRE DEL DEPARTAMENTO Y LA DIVISIÓN A LA QUE PERTENECE.
*/
CREATE TABLE departments
	(
	department_id SERIAL PRIMARY KEY,
	department TEXT NOT NULL,
	division TEXT NOT NULL
	)
/*
ESTE COMANDO MODIFICA LA TABLA 'employees' REALIZANDO VARIOS CAMBIOS ESTRUCTURALES: ESTABLECE QUE LA COLUMNA 'department_id' NO PUEDE SER NULA, ASEGURANDO QUE CADA
EMPLEADO ESTÉ ASIGNADO A UN DEPARTAMENTO. DEFINE UN VALOR POR DEFECTO PARA 'start_date' COMO LA FECHA ACTUAL, AUTOMATIZANDO EL REGISTRO DE LA FECHA DE INICIO. AGREGA UNA
NUEVA COLUMNA 'end_date' PARA REGISTRAR LA FECHA DE FINALIZACIÓN DEL EMPLEO. AÑADE UNA RESTRICCIÓN DE VERIFICACIÓN ('CHECK') PARA ASEGURAR QUE LA FECHA DE NACIMIENTO
('birth_date') SEA ANTERIOR A LA FECHA ACTUAL.
*/
ALTER TABLE employees
ALTER COLUMN department_id SET NOT NULL,
ALTER COLUMN start_date SET DEFAULT CURRENT_DATE,
ADD COLUMN end_date DATE,
ADD CONSTRAINT birth_check CHECK(birth_date < CURRENT_DATE)
/*
ESTE COMANDO MODIFICA LA TABLA 'employees' CAMBIANDO EL NOMBRE DE LA COLUMNA 'job_position' A 'position_title'.
*/
ALTER TABLE employees
RENAME COLUMN job_position TO position_title
/*
ESTE COMANDO INSERTA 26 REGISTROS EN LA TABLA 'employees', CADA UNO REPRESENTANDO A UN EMPLEADO CON DATOS COMO NOMBRE, APELLIDO, TÍTULO DEL PUESTO, SALARIO, FECHA DE
INICIO, FECHA DE NACIMIENTO, ID DE TIENDA, ID DE DEPARTAMENTO, ID DE GERENTE Y FECHA DE FINALIZACIÓN (SI APLICA).
*/
INSERT INTO employees 
VALUES
	(1,'Morrie','Conaboy','CTO',21268.94,'2005-04-30','1983-07-10',1,1,NULL,NULL),
	(2,'Miller','McQuarter','Head of BI',14614.00,'2019-07-23','1978-11-09',1,1,1,NULL),
	(3,'Christalle','McKenny','Head of Sales',12587.00,'1999-02-05','1973-01-09',2,3,1,NULL),
	(4,'Sumner','Seares','SQL Analyst',9515.00,'2006-05-31','1976-08-03',2,1,6,NULL),
	(5,'Romain','Hacard','BI Consultant',7107.00,'2012-09-24','1984-07-14',1,1,6,NULL),
	(6,'Ely','Luscombe','Team Lead Analytics',12564.00,'2002-06-12','1974-08-01',1,1,2,NULL),
	(7,'Clywd','Filyashin','Senior SQL Analyst',10510.00,'2010-04-05','1989-07-23',2,1,2,NULL),
	(8,'Christopher','Blague','SQL Analyst',9428.00,'2007-09-30','1990-12-07',2,2,6,NULL),
	(9,'Roddie','Izen','Software Engineer',4937.00,'2019-03-22','2008-08-30',1,4,6,NULL),
	(10,'Ammamaria','Izhak','Customer Support',2355.00,'2005-03-17','1974-07-27',2,5,3,'2013-04-14'),
	(11,'Carlyn','Stripp','Customer Support',3060.00,'2013-09-06','1981-09-05',1,5,3,NULL),
	(12,'Reuben','McRorie','Software Engineer',7119.00,'1995-12-31','1958-08-15',1,5,6,NULL),
	(13,'Gates','Raison','Marketing Specialist',3910.00,'2013-07-18','1986-06-24',1,3,3,NULL),
	(14,'Jordanna','Raitt','Marketing Specialist',5844.00,'2011-10-23','1993-03-16',2,3,3,NULL),
	(15,'Guendolen','Motton','BI Consultant',8330.00,'2011-01-10','1980-10-22',2,3,6,NULL),
	(16,'Doria','Turbat','Senior SQL Analyst',9278.00,'2010-08-15','1983-01-11',1,1,6,NULL),
	(17,'Cort','Bewlie','Project Manager',5463.00,'2013-05-26','1986-10-05',1,5,3,NULL),
	(18,'Margarita','Eaden','SQL Analyst',5977.00,'2014-09-24','1978-10-08',2,1,6,'2020-03-16'),
	(19,'Hetty','Kingaby','SQL Analyst',7541.00,'2009-08-17','1999-04-25',1,2,6,NULL),
	(20,'Lief','Robardley','SQL Analyst',8981.00,'2002-10-23','1971-01-25',2,3,6,'2016-07-01'),
	(21,'Zaneta','Carlozzi','Working Student',1525.00,'2006-08-29','1995-04-16',1,3,6,'2012-02-19'),
	(22,'Giana','Matz','Working Student',1036.00,'2016-03-18','1987-09-25',1,3,6,NULL),
	(23,'Hamil','Evershed','Web Developper',3088.00,'2022-02-03','2012-03-30',1,4,2,NULL),
	(24,'Lowe','Diamant','Web Developper',6418.00,'2018-12-31','2002-09-07',1,4,2,NULL),
	(25,'Jack','Franklin','SQL Analyst',6771.00,'2013-05-18','2005-10-04',1,2,2,NULL),
	(26,'Jessica','Brown','SQL Analyst',8566.00,'2003-10-23','1965-01-29',1,1,2,NULL)
/*
ESTE COMANDO INSERTA CINCO REGISTROS EN LA TABLA 'departments', CADA UNO REPRESENTANDO UN DEPARTAMENTO DE LA ORGANIZACIÓN. CADA REGISTRO INCLUYE UN ID DE DEPARTAMENTO,
EL NOMBRE DEL DEPARTAMENTO Y LA DIVISIÓN A LA QUE PERTENECE.
*/
INSERT INTO departments
VALUES 
	(1, 'Analytics','IT'),
	(2, 'Finance','Administration'),
	(3, 'Sales','Sales'),
	(4, 'Website','IT'),
	(5, 'Back Office','Administration')
/*
ESTE COMANDO ACTUALIZA EL TÍTULO DEL PUESTO DEL EMPLEADO CON ID 25 EN LA TABLA 'employees', CAMBIÁNDOLO A 'Senior SQL Analyst'.
*/
UPDATE employees
SET position_title = 'Senior SQL Analyst'
WHERE
	emp_id=25
/*
ESTE COMANDO ACTUALIZA EL SALARIO DEL EMPLEADO CON ID 25 EN LA TABLA 'employees', ESTABLECIÉNDOLO EN 7200.
*/
UPDATE employees
SET salary=7200
WHERE
	emp_id=25
/*
ESTE COMANDO ACTUALIZA EL TÍTULO DEL PUESTO DE TODOS LOS EMPLEADOS QUE ACTUALMENTE TIENEN EL CARGO 'Customer Support', CAMBIÁNDOLO A 'Customer Specialist'.
*/
UPDATE employees
SET position_title='Customer Specialist'
WHERE
	position_title='Customer Support'
/*
ESTE COMANDO ACTUALIZA EL SALARIO DE TODOS LOS EMPLEADOS CUYO TÍTULO DE PUESTO CONTIENE LA FRASE 'SQL Analyst', APLICANDO UN INCREMENTO DEL 6%. UTILIZA LA CLÁUSULA 'LIKE'
PARA FILTRAR LOS PUESTOS Y MULTIPLICA EL SALARIO ACTUAL POR 1.06 PARA REFLEJAR EL AUMENTO.
*/
UPDATE employees
SET salary=salary*1.06
WHERE 
	position_title LIKE '%SQL Analyst';
/*
ESTE CÓDIGO SQL CALCULA EL PROMEDIO DE LOS SALARIOS DE LOS EMPLEADOS CUYO PUESTO ES 'SQL ANALYST'. REDONDEA EL RESULTADO PARA UNA PRESENTACIÓN MÁS PRECISA.
*/
SELECT
	ROUND(AVG(salary),2)
FROM
	employees
WHERE
	position_title='SQL Analyst'
/*
ESTE CÓDIGO SQL RECUPERA TODOS LOS DATOS DE LOS EMPLEADOS Y AGREGA DOS CAMPOS ADICIONALES: UNO PARA INDICAR SI EL EMPLEADO ESTÁ ACTIVO (ES DECIR, SI SU FECHA DE
FINALIZACIÓN ES NULA), Y OTRO PARA MOSTRAR EL NOMBRE COMPLETO DE SU JEFE MEDIANTE UNA UNIÓN IZQUIERDA CON LA MISMA TABLA DE EMPLEADOS.
*/
SELECT 
	emp.*,
	CASE
		WHEN emp.end_date IS NULL THEN 'true'
		ELSE 'false' 
	END as is_active,
	mng.first_name ||' '|| mng.last_name AS manager_name
FROM
	employees emp
LEFT OUTER JOIN
	employees mng
ON
	emp.manager_id=mng.emp_id
/*
ESTE CÓDIGO SQL CREA UNA VISTA LLAMADA 'V_EMPLOYEES_INFO' QUE CONTIENE TODOS LOS DATOS DE LOS EMPLEADOS, JUNTO CON DOS CAMPOS ADICIONALES: UNO QUE INDICA SI EL EMPLEADO
ESTÁ ACTIVO (CUANDO LA FECHA DE FINALIZACIÓN ES NULA), Y OTRO QUE MUESTRA EL NOMBRE COMPLETO DE SU JEFE MEDIANTE UNA UNIÓN IZQUIERDA CON LA MISMA TABLA DE EMPLEADOS.
*/
CREATE VIEW v_employees_info
AS SELECT 
	   emp.*,
	   CASE 
	   	   WHEN emp.end_date IS NULL THEN 'true'
	   	   ELSE 'false' 
	   END as is_active,
	   mng.first_name ||' '|| mng.last_name AS manager_name
   FROM
   	   employees emp
   LEFT OUTER JOIN 
	   employees mng
   ON
   	   emp.manager_id=mng.emp_id
/*
ESTE CÓDIGO SQL OBTIENE EL PROMEDIO DE SALARIO POR TÍTULO DE PUESTO A PARTIR DE LA VISTA 'V_EMPLOYEES_INFO'. AGRUPA LOS RESULTADOS POR TÍTULO DE PUESTO, REDONDEA EL
PROMEDIO A DOS DECIMALES Y ORDENA LOS RESULTADOS DE FORMA ASCENDENTE SEGÚN EL PROMEDIO SALARIAL.
*/
SELECT 
	position_title,
	ROUND(AVG(salary),2)
FROM
	v_employees_info
GROUP BY
	position_title
ORDER BY
	2
/*
ESTE CÓDIGO SQL CALCULA EL PROMEDIO DE SALARIO POR DIVISIÓN. REALIZA UNA UNIÓN IZQUIERDA ENTRE LAS TABLAS DE EMPLEADOS Y DEPARTAMENTOS PARA RELACIONAR CADA EMPLEADO CON
SU DIVISIÓN, AGRUPA LOS RESULTADOS POR DIVISIÓN, REDONDEA EL PROMEDIO A DOS DECIMALES Y ORDENA LOS RESULTADOS DE FORMA ASCENDENTE SEGÚN EL PROMEDIO SALARIAL.
*/
SELECT 
	division,
	ROUND(AVG(salary),2)
FROM
	employees e
LEFT OUTER JOIN
	departments d 
ON
	e.department_id=d.department_id
GROUP BY
	division
ORDER BY
	2
/*
ESTE CÓDIGO SQL RECUPERA INFORMACIÓN DETALLADA DE CADA EMPLEADO, INCLUYENDO SU IDENTIFICADOR, NOMBRE, APELLIDO, TÍTULO DE PUESTO Y SALARIO. ADEMÁS, AGREGA UNA COLUMNA QUE
MUESTRA EL PROMEDIO DE SALARIO POR TÍTULO DE PUESTO UTILIZANDO UNA FUNCIÓN DE VENTANA (WINDOW FUNCTION) CON PARTICIÓN POR TÍTULO DE PUESTO. EL RESULTADO SE ORDENA POR
IDENTIFICADOR DE EMPLEADO.
*/
SELECT
	emp_id,
	first_name,
	last_name,
	position_title,
	salary,
	ROUND(AVG(salary) OVER(PARTITION BY position_title),2) as avg_position_sal
FROM
	employees
ORDER BY
	1
/*
ESTE CÓDIGO SQL CUENTA CUÁNTOS EMPLEADOS TIENEN UN SALARIO INFERIOR AL PROMEDIO DE SU MISMO TÍTULO DE PUESTO. UTILIZA UNA SUBCONSULTA CON UNA FUNCIÓN DE VENTANA PARA
CALCULAR EL PROMEDIO DE SALARIO POR TÍTULO DE PUESTO Y LUEGO FILTRA AQUELLOS CUYOS SALARIOS SON MENORES A ESE PROMEDIO.
*/
SELECT
	COUNT(*)
FROM
	(SELECT 
		 emp_id,
		 salary,
		 ROUND(AVG(salary) OVER(PARTITION BY position_title),2) as avg_pos_sal
	 FROM 
	 	 employees) a
WHERE 
	salary<avg_pos_sal
/*
ESTE CÓDIGO SQL RECUPERA EL IDENTIFICADOR, SALARIO Y FECHA DE INICIO DE CADA EMPLEADO, Y CALCULA UNA SUMA ACUMULADA DE LOS SALARIOS ORDENADA POR FECHA DE INICIO
UTILIZANDO UNA FUNCIÓN DE VENTANA. EL RESULTADO MUESTRA CÓMO SE ACUMULAN LOS SALARIOS A LO LARGO DEL TIEMPO DE INGRESO DE LOS EMPLEADOS.
*/
SELECT 
	emp_id,
	salary,
	start_date,
	SUM(salary) OVER(ORDER BY start_date) as ruuning_total_of_salary
FROM
	employees
/*
ESTE CÓDIGO SQL CALCULA UNA SUMA ACUMULADA DE SALARIOS ORDENADA POR FECHA DE INICIO, TENIENDO EN CUENTA TANTO LOS INGRESOS COMO LAS SALIDAS DE EMPLEADOS. UTILIZA UNA
SUBCONSULTA QUE UNE DOS CONJUNTOS DE DATOS: UNO CON LOS SALARIOS POSITIVOS DE EMPLEADOS ACTIVOS Y OTRO CON LOS SALARIOS NEGATIVOS DE EMPLEADOS INACTIVOS (CUYA FECHA DE
FINALIZACIÓN SE USA COMO REFERENCIA). LA FUNCIÓN DE VENTANA SUMA LOS SALARIOS ORDENADOS CRONOLÓGICAMENTE PARA MOSTRAR LA EVOLUCIÓN DEL COSTO TOTAL DE NÓMINA A LO LARGO
DEL TIEMPO.
*/
SELECT 
	start_date,
	SUM(salary) OVER(ORDER BY start_date)
FROM
	(SELECT 
		 emp_id,
		 salary,
		 start_date
	 FROM
	 	 employees
	 UNION 
		 SELECT 
			 emp_id,
			 -salary,
			 end_date
		 FROM
		 	 v_employees_info
		 WHERE
		 	 is_active ='false'
		 ORDER BY
		 	 start_date) a
/*
ESTE CÓDIGO SQL RECUPERA EL NOMBRE, TÍTULO DE PUESTO Y SALARIO DE LOS EMPLEADOS QUE TIENEN EL SALARIO MÁS ALTO DENTRO DE SU RESPECTIVO TÍTULO DE PUESTO. UTILIZA UNA
SUBCONSULTA CORRELACIONADA PARA COMPARAR EL SALARIO DE CADA EMPLEADO CON EL MÁXIMO SALARIO DE SU MISMO PUESTO.
*/
SELECT
	first_name,
	position_title,
	salary
FROM
	employees e1
WHERE
	salary = (SELECT
				  MAX(salary)
			  FROM
			  	  employees e2
			  WHERE
			  	  e1.position_title=e2.position_title)
/*
ESTE CÓDIGO SQL RECUPERA EL NOMBRE, TÍTULO DE PUESTO, SALARIO Y EL PROMEDIO DE SALARIO PARA ESE MISMO PUESTO DE LOS EMPLEADOS QUE TIENEN EL SALARIO MÁS ALTO EN SU
CATEGORÍA. UTILIZA UNA SUBCONSULTA CORRELACIONADA PARA OBTENER EL PROMEDIO DE SALARIO POR TÍTULO DE PUESTO Y OTRA PARA IDENTIFICAR EL SALARIO MÁXIMO DENTRO DE CADA
PUESTO.
*/
SELECT
	first_name,
	position_title,
	salary,
	(SELECT
		 ROUND(AVG(salary),2) as avg_in_pos FROM employees e3
	 WHERE
	 	 e1.position_title=e3.position_title)
FROM
	employees e1
WHERE
	salary = (SELECT
				  MAX(salary)
			  FROM
			  	  employees e2
			  WHERE
			  	  e1.position_title=e2.position_title)
/*
ESTE CÓDIGO SQL RECUPERA EL NOMBRE, TÍTULO DE PUESTO, SALARIO Y EL PROMEDIO DE SALARIO DEL PUESTO PARA AQUELLOS EMPLEADOS QUE TIENEN EL SALARIO MÁS ALTO EN SU CATEGORÍA,
PERO CUYO SALARIO NO COINCIDE CON EL PROMEDIO DE SU PUESTO. UTILIZA SUBCONSULTAS CORRELACIONADAS PARA OBTENER TANTO EL SALARIO MÁXIMO COMO EL PROMEDIO POR TÍTULO DE
PUESTO, Y FILTRA LOS RESULTADOS PARA EXCLUIR LOS CASOS DONDE EL SALARIO MÁXIMO ES IGUAL AL PROMEDIO.
*/
SELECT
	first_name,
	position_title,
	salary,
	(SELECT
		 ROUND(AVG(salary),2) as avg_in_pos FROM employees e3
	 WHERE
	 	 e1.position_title=e3.position_title)
FROM
	employees e1
WHERE
	salary = (SELECT
				  MAX(salary)
			  FROM
			  	  employees e2
			  WHERE
			  	  e1.position_title=e2.position_title)
	AND salary<>(SELECT
					 ROUND(AVG(salary),2) as avg_in_pos FROM employees e3
				 WHERE
				 	 e1.position_title=e3.position_title)
/*
ESTE CÓDIGO SQL GENERA UN RESUMEN AGRUPADO DE INFORMACIÓN SALARIAL POR DIVISIÓN, DEPARTAMENTO Y TÍTULO DE PUESTO. UTILIZA LA CLÁUSULA `ROLLUP` PARA INCLUIR TOTALES
PARCIALES Y GENERALES EN LA AGRUPACIÓN. SE REALIZA UNA UNIÓN NATURAL ENTRE LAS TABLAS DE EMPLEADOS Y DEPARTAMENTOS, Y SE CALCULAN LA SUMA TOTAL DE SALARIOS, EL NÚMERO DE
EMPLEADOS Y EL PROMEDIO DE SALARIO REDONDEADO A DOS DECIMALES. LOS RESULTADOS SE ORDENAN POR DIVISIÓN, DEPARTAMENTO Y TÍTULO DE PUESTO.
*/
SELECT 
	division,
	department,
	position_title,
	SUM(salary),
	COUNT(*),
	ROUND(AVG(salary),2)
FROM
	employees
NATURAL JOIN
	departments
GROUP BY 
	ROLLUP(
		division,
		department,
		position_title
	)
ORDER BY 
	1,2,3
/*
ESTE CÓDIGO SQL RECUPERA EL IDENTIFICADOR, TÍTULO DE PUESTO, DEPARTAMENTO Y SALARIO DE CADA EMPLEADO, Y ASIGNA UN RANGO BASADO EN SU SALARIO DENTRO DE CADA DEPARTAMENTO.
UTILIZA LA FUNCIÓN DE VENTANA `RANK()` CON PARTICIÓN POR DEPARTAMENTO Y ORDENAMIENTO DESCENDENTE DE SALARIO PARA DETERMINAR LA POSICIÓN RELATIVA DE CADA EMPLEADO EN SU
DEPARTAMENTO SEGÚN SU SALARIO. LA UNIÓN NATURAL IZQUIERDA ENTRE EMPLEADOS Y DEPARTAMENTOS PERMITE ACCEDER A LA INFORMACIÓN DE AMBAS TABLAS.
*/
SELECT
	emp_id,
	position_title,
	department,
	salary,
	RANK() OVER(PARTITION BY department ORDER BY salary DESC)
FROM
	employees
NATURAL LEFT JOIN
	departments
/*
ESTE CÓDIGO SQL RECUPERA LOS EMPLEADOS CON EL SALARIO MÁS ALTO EN CADA DEPARTAMENTO. UTILIZA UNA SUBCONSULTA QUE ASIGNA UN RANGO A CADA EMPLEADO SEGÚN SU SALARIO DENTRO
DE SU DEPARTAMENTO MEDIANTE LA FUNCIÓN DE VENTANA `RANK()`. LUEGO, FILTRA LOS RESULTADOS PARA MOSTRAR ÚNICAMENTE AQUELLOS EMPLEADOS CUYO RANGO ES IGUAL A 1, ES DECIR,
LOS MEJOR PAGADOS EN SU DEPARTAMENTO.
*/
SELECT
	*
FROM
	(SELECT
		 emp_id,
		 position_title,
		 department,
		 salary,
		 RANK() OVER(PARTITION BY department ORDER BY salary DESC)
	 FROM
	 	 employees
	 NATURAL LEFT JOIN
	 	departments) a
WHERE
	rank=1